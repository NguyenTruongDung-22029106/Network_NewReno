#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Script ph√¢n t√≠ch ƒë·∫ßy ƒë·ªß v√† chi ti·∫øt TCP NewReno vs TCP Reno
Bao g·ªìm bi·ªÉu ƒë·ªì, th·ªëng k√™, v√† b√°o c√°o chi ti·∫øt
"""

import matplotlib.pyplot as plt
import matplotlib.patches as mpatches
import numpy as np
import pandas as pd
import os
import seaborn as sns
from datetime import datetime
from scipy import stats
import warnings
warnings.filterwarnings('ignore')

# Set style cho bi·ªÉu ƒë·ªì ƒë·∫πp h∆°n
try:
    plt.style.use('seaborn-v0_8')
except OSError:
    try:
        plt.style.use('seaborn')
    except OSError:
        plt.style.use('default')
sns.set_palette("husl")

class TCPAnalyzer:
    def __init__(self):
        self.data = {}
        self.stats = {}
        
    def read_rx_data(self, filename, flow_name):
        """ƒê·ªçc d·ªØ li·ªáu throughput t·ª´ file rx data"""
        if not os.path.exists(filename):
            print(f"‚ö†Ô∏è  File {filename} kh√¥ng t·ªìn t·∫°i")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(filename, sep='\t', header=None, names=['time', 'bytes'])
            df['flow'] = flow_name
            df['cumulative_bytes'] = df['bytes'].cumsum()
            df['throughput_mbps'] = (df['cumulative_bytes'] * 8) / (df['time'] * 1e6)
            df['instant_throughput'] = (df['bytes'] * 8) / 1e6  # Mbps t·ª©c th·ªùi
            return df
        except Exception as e:
            print(f"‚ùå L·ªói ƒë·ªçc file {filename}: {e}")
            return pd.DataFrame()
    
    def read_cwnd_data(self, filename, flow_name):
        """ƒê·ªçc d·ªØ li·ªáu congestion window t·ª´ file cwnd data"""
        if not os.path.exists(filename):
            print(f"‚ö†Ô∏è  File {filename} kh√¥ng t·ªìn t·∫°i")
            return pd.DataFrame()
        
        try:
            df = pd.read_csv(filename, sep='\t', header=None, names=['time', 'cwnd'])
            df['flow'] = flow_name
            df['cwnd_kb'] = df['cwnd'] / 1024
            return df
        except Exception as e:
            print(f"‚ùå L·ªói ƒë·ªçc file {filename}: {e}")
            return pd.DataFrame()
    
    def load_all_data(self):
        """T·∫£i t·∫•t c·∫£ d·ªØ li·ªáu t·ª´ c√°c file"""
        print("üìä ƒêang t·∫£i d·ªØ li·ªáu t·ª´ c√°c file...")
        
        # TCP flows
        self.data['newreno_rx'] = self.read_rx_data('enterprise-main-newreno-rx.data', 'TCP NewReno')
        self.data['newreno_cwnd'] = self.read_cwnd_data('enterprise-main-newreno-cwnd.data', 'TCP NewReno')
        self.data['reno_rx'] = self.read_rx_data('enterprise-reno-rx.data', 'TCP Reno')
        self.data['reno_cwnd'] = self.read_cwnd_data('enterprise-reno-cwnd.data', 'TCP Reno')
        
        # Competing flows
        self.data['comp1_rx'] = self.read_rx_data('enterprise-comp1-newreno-rx.data', 'Competing TCP 1')
        self.data['comp1_cwnd'] = self.read_cwnd_data('enterprise-comp1-newreno-cwnd.data', 'Competing TCP 1')
        self.data['comp2_rx'] = self.read_rx_data('enterprise-comp2-newreno-rx.data', 'Competing TCP 2')
        self.data['comp2_cwnd'] = self.read_cwnd_data('enterprise-comp2-newreno-cwnd.data', 'Competing TCP 2')
        
        # UDP flows
        self.data['udp1_rx'] = self.read_rx_data('enterprise-udp1-rx.data', 'UDP CBR 1')
        self.data['udp2_rx'] = self.read_rx_data('enterprise-udp2-rx.data', 'UDP CBR 2')
        
        print("‚úÖ ƒê√£ t·∫£i xong t·∫•t c·∫£ d·ªØ li·ªáu")
    
    def calculate_statistics(self):
        """T√≠nh to√°n th·ªëng k√™ chi ti·∫øt"""
        print("üî¢ ƒêang t√≠nh to√°n th·ªëng k√™...")
        
        for key, df in self.data.items():
            if df.empty:
                continue
                
            flow_name = df['flow'].iloc[0] if 'flow' in df.columns else key
            
            if 'bytes' in df.columns:  # RX data
                total_bytes = df['bytes'].sum()
                duration = df['time'].max() - df['time'].min() if len(df) > 1 else 0
                avg_throughput = (total_bytes * 8) / (duration * 1e6) if duration > 0 else 0
                packets = len(df)
                
                # T√≠nh throughput theo c·ª≠a s·ªï tr∆∞·ª£t 5 gi√¢y
                df_windowed = df.copy()
                window_size = 5.0
                df_windowed['time_window'] = (df_windowed['time'] // window_size) * window_size
                windowed_stats = df_windowed.groupby('time_window')['bytes'].sum()
                windowed_throughput = (windowed_stats * 8) / (window_size * 1e6)
                
                self.stats[key] = {
                    'flow_name': flow_name,
                    'total_bytes': total_bytes,
                    'total_mb': total_bytes / 1e6,
                    'duration': duration,
                    'avg_throughput': avg_throughput,
                    'packets': packets,
                    'start_time': df['time'].min(),
                    'end_time': df['time'].max(),
                    'windowed_throughput': windowed_throughput,
                    'max_instant_throughput': df['instant_throughput'].max() if 'instant_throughput' in df else 0,
                    'min_instant_throughput': df['instant_throughput'].min() if 'instant_throughput' in df else 0,
                    'std_throughput': df['instant_throughput'].std() if 'instant_throughput' in df else 0
                }
                
            elif 'cwnd' in df.columns:  # CWND data
                max_cwnd = df['cwnd'].max()
                min_cwnd = df['cwnd'].min()
                avg_cwnd = df['cwnd'].mean()
                std_cwnd = df['cwnd'].std()
                
                # T√≠nh bi·∫øn ƒë·ªông CWND
                df['cwnd_change'] = df['cwnd'].diff()
                increases = (df['cwnd_change'] > 0).sum()
                decreases = (df['cwnd_change'] < 0).sum()
                
                self.stats[key] = {
                    'flow_name': flow_name,
                    'max_cwnd': max_cwnd,
                    'min_cwnd': min_cwnd,
                    'avg_cwnd': avg_cwnd,
                    'std_cwnd': std_cwnd,
                    'max_cwnd_kb': max_cwnd / 1024,
                    'min_cwnd_kb': min_cwnd / 1024,
                    'avg_cwnd_kb': avg_cwnd / 1024,
                    'cwnd_increases': increases,
                    'cwnd_decreases': decreases,
                    'cwnd_stability': 1 - (std_cwnd / avg_cwnd) if avg_cwnd > 0 else 0
                }
        
        print("‚úÖ Ho√†n th√†nh t√≠nh to√°n th·ªëng k√™")
    
    def create_comprehensive_plots(self):
        """T·∫°o c√°c bi·ªÉu ƒë·ªì ph√¢n t√≠ch ƒë·∫ßy ƒë·ªß"""
        print("üé® ƒêang t·∫°o bi·ªÉu ƒë·ªì ph√¢n t√≠ch ƒë·∫ßy ƒë·ªß...")
        
        # Figure 1: Throughput Analysis (2x2)
        fig1, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        fig1.suptitle('üìà Ph√¢n T√≠ch Throughput Chi Ti·∫øt', fontsize=16, fontweight='bold')
        
        # 1.1: Throughput t√≠ch l≈©y theo th·ªùi gian
        if not self.data['newreno_rx'].empty:
            ax1.plot(self.data['newreno_rx']['time'].values, self.data['newreno_rx']['throughput_mbps'].values, 
                    'g-', label='TCP NewReno', linewidth=2.5, alpha=0.8)
        if not self.data['reno_rx'].empty:
            ax1.plot(self.data['reno_rx']['time'].values, self.data['reno_rx']['throughput_mbps'].values, 
                    'r-', label='TCP Reno', linewidth=2.5, alpha=0.8)
        
        ax1.set_xlabel('Th·ªùi gian (gi√¢y)', fontsize=11)
        ax1.set_ylabel('Throughput t√≠ch l≈©y (Mbps)', fontsize=11)
        ax1.set_title('Throughput T√≠ch L≈©y Theo Th·ªùi Gian', fontweight='bold')
        ax1.legend(fontsize=10)
        ax1.grid(True, alpha=0.3)
        
        # 1.2: Throughput t·ª©c th·ªùi (moving average)
        window = 50  # C·ª≠a s·ªï trung b√¨nh tr∆∞·ª£t
        if not self.data['newreno_rx'].empty and len(self.data['newreno_rx']) > window:
            newreno_smooth = self.data['newreno_rx']['instant_throughput'].rolling(window=window).mean()
            ax2.plot(self.data['newreno_rx']['time'].values, newreno_smooth.values, 
                    'g-', label='TCP NewReno (MA)', linewidth=2)
        if not self.data['reno_rx'].empty and len(self.data['reno_rx']) > window:
            reno_smooth = self.data['reno_rx']['instant_throughput'].rolling(window=window).mean()
            ax2.plot(self.data['reno_rx']['time'].values, reno_smooth.values, 
                    'r-', label='TCP Reno (MA)', linewidth=2)
        
        ax2.set_xlabel('Th·ªùi gian (gi√¢y)', fontsize=11)
        ax2.set_ylabel('Throughput t·ª©c th·ªùi (Mbps)', fontsize=11)
        ax2.set_title('Throughput T·ª©c Th·ªùi (Moving Average)', fontweight='bold')
        ax2.legend(fontsize=10)
        ax2.grid(True, alpha=0.3)
        
        # 1.3: Histogram ph√¢n ph·ªëi throughput
        if not self.data['newreno_rx'].empty:
            ax3.hist(self.data['newreno_rx']['instant_throughput'].values, bins=50, alpha=0.6, 
                    color='green', label='TCP NewReno', density=True)
        if not self.data['reno_rx'].empty:
            ax3.hist(self.data['reno_rx']['instant_throughput'].values, bins=50, alpha=0.6, 
                    color='red', label='TCP Reno', density=True)
        
        ax3.set_xlabel('Throughput t·ª©c th·ªùi (Mbps)', fontsize=11)
        ax3.set_ylabel('M·∫≠t ƒë·ªô x√°c su·∫•t', fontsize=11)
        ax3.set_title('Ph√¢n Ph·ªëi Throughput', fontweight='bold')
        ax3.legend(fontsize=10)
        ax3.grid(True, alpha=0.3)
        
        # 1.4: Boxplot so s√°nh throughput
        throughput_data = []
        labels = []
        if not self.data['newreno_rx'].empty:
            throughput_data.append(self.data['newreno_rx']['instant_throughput'].values)
            labels.append('NewReno')
        if not self.data['reno_rx'].empty:
            throughput_data.append(self.data['reno_rx']['instant_throughput'].values)
            labels.append('Reno')
        
        if throughput_data:
            bp = ax4.boxplot(throughput_data, labels=labels, patch_artist=True)
            colors = ['lightgreen', 'lightcoral']
            for patch, color in zip(bp['boxes'], colors[:len(bp['boxes'])]):
                patch.set_facecolor(color)
        
        ax4.set_ylabel('Throughput t·ª©c th·ªùi (Mbps)', fontsize=11)
        ax4.set_title('So S√°nh Ph√¢n Ph·ªëi Throughput', fontweight='bold')
        ax4.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('tcp_throughput_analysis.png', dpi=300, bbox_inches='tight')
        print("‚úÖ ƒê√£ l∆∞u: tcp_throughput_analysis.png")
        
        # Figure 2: Congestion Window Analysis (2x2)
        fig2, ((ax5, ax6), (ax7, ax8)) = plt.subplots(2, 2, figsize=(16, 12))
        fig2.suptitle('üîß Ph√¢n T√≠ch Congestion Window Chi Ti·∫øt', fontsize=16, fontweight='bold')
        
        # 2.1: CWND theo th·ªùi gian
        if not self.data['newreno_cwnd'].empty:
            ax5.plot(self.data['newreno_cwnd']['time'].values, self.data['newreno_cwnd']['cwnd_kb'].values, 
                    'g-', label='TCP NewReno', linewidth=2, alpha=0.8)
        if not self.data['reno_cwnd'].empty:
            ax5.plot(self.data['reno_cwnd']['time'].values, self.data['reno_cwnd']['cwnd_kb'].values, 
                    'r-', label='TCP Reno', linewidth=2, alpha=0.8)
        
        ax5.set_xlabel('Th·ªùi gian (gi√¢y)', fontsize=11)
        ax5.set_ylabel('Congestion Window (KB)', fontsize=11)
        ax5.set_title('Bi·∫øn ƒê·ªông CWND Theo Th·ªùi Gian', fontweight='bold')
        ax5.legend(fontsize=10)
        ax5.grid(True, alpha=0.3)
        
        # 2.2: CWND growth rate
        if not self.data['newreno_cwnd'].empty:
            newreno_growth = self.data['newreno_cwnd']['cwnd'].diff() / self.data['newreno_cwnd']['time'].diff()
            ax6.plot(self.data['newreno_cwnd']['time'].values[1:], newreno_growth.values[1:], 
                    'g-', label='TCP NewReno', alpha=0.7)
        if not self.data['reno_cwnd'].empty:
            reno_growth = self.data['reno_cwnd']['cwnd'].diff() / self.data['reno_cwnd']['time'].diff()
            ax6.plot(self.data['reno_cwnd']['time'].values[1:], reno_growth.values[1:], 
                    'r-', label='TCP Reno', alpha=0.7)
        
        ax6.set_xlabel('Th·ªùi gian (gi√¢y)', fontsize=11)
        ax6.set_ylabel('T·ªëc ƒë·ªô thay ƒë·ªïi CWND (bytes/s)', fontsize=11)
        ax6.set_title('T·ªëc ƒê·ªô Thay ƒê·ªïi CWND', fontweight='bold')
        ax6.legend(fontsize=10)
        ax6.grid(True, alpha=0.3)
        
        # 2.3: CWND histogram
        if not self.data['newreno_cwnd'].empty:
            ax7.hist(self.data['newreno_cwnd']['cwnd_kb'].values, bins=30, alpha=0.6, 
                    color='green', label='TCP NewReno', density=True)
        if not self.data['reno_cwnd'].empty:
            ax7.hist(self.data['reno_cwnd']['cwnd_kb'].values, bins=30, alpha=0.6, 
                    color='red', label='TCP Reno', density=True)
        
        ax7.set_xlabel('Congestion Window (KB)', fontsize=11)
        ax7.set_ylabel('M·∫≠t ƒë·ªô x√°c su·∫•t', fontsize=11)
        ax7.set_title('Ph√¢n Ph·ªëi CWND', fontweight='bold')
        ax7.legend(fontsize=10)
        ax7.grid(True, alpha=0.3)
        
        # 2.4: CWND vs Throughput correlation
        if not self.data['newreno_rx'].empty and not self.data['newreno_cwnd'].empty:
            # Interpolate ƒë·ªÉ match time stamps
            common_times = np.intersect1d(
                np.round(self.data['newreno_rx']['time'].values, 1),
                np.round(self.data['newreno_cwnd']['time'].values, 1)
            )
            if len(common_times) > 10:
                rx_interp = np.interp(common_times, self.data['newreno_rx']['time'].values, 
                                    self.data['newreno_rx']['instant_throughput'].values)
                cwnd_interp = np.interp(common_times, self.data['newreno_cwnd']['time'].values, 
                                      self.data['newreno_cwnd']['cwnd_kb'].values)
                ax8.scatter(cwnd_interp, rx_interp, alpha=0.6, color='green', 
                          label='TCP NewReno', s=20)
        
        if not self.data['reno_rx'].empty and not self.data['reno_cwnd'].empty:
            common_times = np.intersect1d(
                np.round(self.data['reno_rx']['time'].values, 1),
                np.round(self.data['reno_cwnd']['time'].values, 1)
            )
            if len(common_times) > 10:
                rx_interp = np.interp(common_times, self.data['reno_rx']['time'].values, 
                                    self.data['reno_rx']['instant_throughput'].values)
                cwnd_interp = np.interp(common_times, self.data['reno_cwnd']['time'].values, 
                                      self.data['reno_cwnd']['cwnd_kb'].values)
                ax8.scatter(cwnd_interp, rx_interp, alpha=0.6, color='red', 
                          label='TCP Reno', s=20)
        
        ax8.set_xlabel('Congestion Window (KB)', fontsize=11)
        ax8.set_ylabel('Throughput t·ª©c th·ªùi (Mbps)', fontsize=11)
        ax8.set_title('T∆∞∆°ng Quan CWND vs Throughput', fontweight='bold')
        ax8.legend(fontsize=10)
        ax8.grid(True, alpha=0.3)
        
        plt.tight_layout()
        plt.savefig('tcp_cwnd_analysis.png', dpi=300, bbox_inches='tight')
        print("‚úÖ ƒê√£ l∆∞u: tcp_cwnd_analysis.png")
        
        # Figure 3: Network Overview & Competing Flows
        fig3, ((ax9, ax10), (ax11, ax12)) = plt.subplots(2, 2, figsize=(16, 12))
        fig3.suptitle('üåê Ph√¢n T√≠ch To√†n M·∫°ng & Lu·ªìng C·∫°nh Tranh', fontsize=16, fontweight='bold')
        
        # 3.1: All flows throughput
        colors = ['green', 'red', 'blue', 'orange', 'purple', 'brown']
        flow_names = ['TCP NewReno', 'TCP Reno', 'Competing TCP 1', 'Competing TCP 2', 'UDP CBR 1', 'UDP CBR 2']
        data_keys = ['newreno_rx', 'reno_rx', 'comp1_rx', 'comp2_rx', 'udp1_rx', 'udp2_rx']
        
        for i, (key, color, name) in enumerate(zip(data_keys, colors, flow_names)):
            if key in self.data and not self.data[key].empty:
                if len(self.data[key]) > 50:  # Smooth data if enough points
                    smooth_throughput = self.data[key]['instant_throughput'].rolling(window=30).mean()
                    ax9.plot(self.data[key]['time'].values, smooth_throughput.values, 
                            color=color, label=name, linewidth=2, alpha=0.8)
                else:
                    ax9.plot(self.data[key]['time'].values, self.data[key]['instant_throughput'].values, 
                            color=color, label=name, linewidth=2, alpha=0.8)
        
        ax9.set_xlabel('Th·ªùi gian (gi√¢y)', fontsize=11)
        ax9.set_ylabel('Throughput t·ª©c th·ªùi (Mbps)', fontsize=11)
        ax9.set_title('T·∫•t C·∫£ Lu·ªìng D·ªØ Li·ªáu', fontweight='bold')
        ax9.legend(fontsize=9)
        ax9.grid(True, alpha=0.3)
        
        # 3.2: Network utilization over time
        time_range = np.arange(0, 200, 1)  # 1 second intervals
        total_utilization = np.zeros_like(time_range, dtype=float)
        
        for key in data_keys:
            if key in self.data and not self.data[key].empty:
                df = self.data[key]
                for t in time_range:
                    mask = (df['time'] >= t) & (df['time'] < t + 1)
                    if mask.any():
                        total_utilization[t] += df[mask]['instant_throughput'].mean()
        
        ax10.plot(time_range, total_utilization, 'b-', linewidth=2, label='T·ªïng utilization')
        ax10.axhline(y=5, color='red', linestyle='--', alpha=0.7, label='WAN limit (5 Mbps)')
        ax10.fill_between(time_range, total_utilization, alpha=0.3)
        
        ax10.set_xlabel('Th·ªùi gian (gi√¢y)', fontsize=11)
        ax10.set_ylabel('Network Utilization (Mbps)', fontsize=11)
        ax10.set_title('S·ª≠ D·ª•ng BƒÉng Th√¥ng M·∫°ng', fontweight='bold')
        ax10.legend(fontsize=10)
        ax10.grid(True, alpha=0.3)
        
        # 3.3: Flow comparison bar chart
        flow_stats = []
        for key in ['newreno_rx', 'reno_rx', 'comp1_rx', 'comp2_rx']:
            if key in self.stats:
                flow_stats.append({
                    'name': self.stats[key]['flow_name'],
                    'throughput': self.stats[key]['avg_throughput'],
                    'total_mb': self.stats[key]['total_mb']
                })
        
        if flow_stats:
            names = [f['name'] for f in flow_stats]
            throughputs = [f['throughput'] for f in flow_stats]
            
            bars = ax11.bar(names, throughputs, color=['green', 'red', 'blue', 'orange'][:len(names)], alpha=0.7)
            ax11.set_ylabel('Throughput trung b√¨nh (Mbps)', fontsize=11)
            ax11.set_title('So S√°nh Throughput C√°c Lu·ªìng TCP', fontweight='bold')
            ax11.tick_params(axis='x', rotation=45)
            ax11.grid(True, alpha=0.3)
            
            # Add value labels on bars
            for bar, val in zip(bars, throughputs):
                ax11.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.01,
                         f'{val:.2f}', ha='center', va='bottom', fontweight='bold')
        
        # 3.4: Performance comparison radar chart
        if 'newreno_rx' in self.stats and 'reno_rx' in self.stats:
            categories = ['Throughput', 'Stability', 'Efficiency', 'CWND Size', 'Responsiveness']
            
            # Normalize metrics to 0-1 scale for radar chart
            newreno_metrics = [
                self.stats['newreno_rx']['avg_throughput'] / 2.0,  # Normalize by max expected
                1 - (self.stats['newreno_rx']['std_throughput'] / self.stats['newreno_rx']['avg_throughput']) if self.stats['newreno_rx']['avg_throughput'] > 0 else 0,
                self.stats['newreno_rx']['total_mb'] / max(self.stats['newreno_rx']['total_mb'], self.stats['reno_rx']['total_mb']),
                (self.stats['newreno_cwnd']['avg_cwnd_kb'] / 200) if 'newreno_cwnd' in self.stats else 0.5,  # Normalize by typical max
                0.8  # Assumed based on NewReno characteristics
            ]
            
            reno_metrics = [
                self.stats['reno_rx']['avg_throughput'] / 2.0,
                1 - (self.stats['reno_rx']['std_throughput'] / self.stats['reno_rx']['avg_throughput']) if self.stats['reno_rx']['avg_throughput'] > 0 else 0,
                self.stats['reno_rx']['total_mb'] / max(self.stats['newreno_rx']['total_mb'], self.stats['reno_rx']['total_mb']),
                (self.stats['reno_cwnd']['avg_cwnd_kb'] / 200) if 'reno_cwnd' in self.stats else 0.4,
                0.6  # Assumed based on Reno characteristics
            ]
            
            angles = np.linspace(0, 2 * np.pi, len(categories), endpoint=False).tolist()
            angles += angles[:1]  # Complete the circle
            
            newreno_metrics += newreno_metrics[:1]
            reno_metrics += reno_metrics[:1]
            
            ax12 = plt.subplot(2, 2, 4, projection='polar')
            ax12.plot(angles, newreno_metrics, 'g-', linewidth=2, label='TCP NewReno')
            ax12.fill(angles, newreno_metrics, alpha=0.25, color='green')
            ax12.plot(angles, reno_metrics, 'r-', linewidth=2, label='TCP Reno')
            ax12.fill(angles, reno_metrics, alpha=0.25, color='red')
            
            ax12.set_xticks(angles[:-1])
            ax12.set_xticklabels(categories, fontsize=10)
            ax12.set_ylim(0, 1)
            ax12.set_title('So S√°nh Hi·ªáu Su·∫•t T·ªïng Th·ªÉ', fontweight='bold', pad=20)
            ax12.legend(loc='upper right', bbox_to_anchor=(1.3, 1.0))
        
        plt.tight_layout()
        plt.savefig('tcp_network_analysis.png', dpi=300, bbox_inches='tight')
        print("‚úÖ ƒê√£ l∆∞u: tcp_network_analysis.png")
    
    def generate_detailed_report(self):
        """T·∫°o b√°o c√°o chi ti·∫øt"""
        print("üìù ƒêang t·∫°o b√°o c√°o chi ti·∫øt...")
        
        report = []
        report.append("="*80)
        report.append("           B√ÅO C√ÅO PH√ÇN T√çCH CHI TI·∫æT TCP NEWRENO VS TCP RENO")
        report.append("="*80)
        report.append(f"Th·ªùi gian t·∫°o b√°o c√°o: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        report.append("")
        
        # Executive Summary
        report.append("üìã T√ìM T·∫ÆT ƒêI·ªÄU H√ÄNH")
        report.append("-" * 40)
        if 'newreno_rx' in self.stats and 'reno_rx' in self.stats:
            newreno_perf = self.stats['newreno_rx']['avg_throughput']
            reno_perf = self.stats['reno_rx']['avg_throughput']
            improvement = ((newreno_perf - reno_perf) / reno_perf * 100) if reno_perf > 0 else 0
            
            report.append(f"‚Ä¢ TCP NewReno cho hi·ªáu su·∫•t {improvement:.1f}% t·ªët h∆°n TCP Reno")
            report.append(f"‚Ä¢ Throughput trung b√¨nh: NewReno {newreno_perf:.2f} Mbps vs Reno {reno_perf:.2f} Mbps")
            report.append(f"‚Ä¢ T·ªïng d·ªØ li·ªáu truy·ªÅn: NewReno {self.stats['newreno_rx']['total_mb']:.1f} MB vs Reno {self.stats['reno_rx']['total_mb']:.1f} MB")
            
            if 'newreno_cwnd' in self.stats and 'reno_cwnd' in self.stats:
                cwnd_improvement = ((self.stats['newreno_cwnd']['avg_cwnd'] - self.stats['reno_cwnd']['avg_cwnd']) / self.stats['reno_cwnd']['avg_cwnd'] * 100)
                report.append(f"‚Ä¢ CWND trung b√¨nh: NewReno {self.stats['newreno_cwnd']['avg_cwnd_kb']:.0f} KB vs Reno {self.stats['reno_cwnd']['avg_cwnd_kb']:.0f} KB ({cwnd_improvement:+.1f}%)")
        
        report.append("")
        
        # Detailed Analysis
        report.append("üîç PH√ÇN T√çCH CHI TI·∫æT")
        report.append("-" * 40)
        
        for key, stats in self.stats.items():
            if 'flow_name' not in stats:
                continue
                
            report.append(f"\nüî∏ {stats['flow_name'].upper()}")
            report.append("  " + "‚îÄ" * 30)
            
            if 'avg_throughput' in stats:  # RX data
                report.append(f"  üìä Throughput:")
                report.append(f"     ‚Ä¢ Trung b√¨nh: {stats['avg_throughput']:.3f} Mbps")
                report.append(f"     ‚Ä¢ T·ªëi ƒëa: {stats.get('max_instant_throughput', 0):.3f} Mbps")
                report.append(f"     ‚Ä¢ T·ªëi thi·ªÉu: {stats.get('min_instant_throughput', 0):.3f} Mbps")
                report.append(f"     ‚Ä¢ ƒê·ªô l·ªách chu·∫©n: {stats.get('std_throughput', 0):.3f} Mbps")
                
                report.append(f"  üì¶ D·ªØ li·ªáu:")
                report.append(f"     ‚Ä¢ T·ªïng bytes: {stats['total_bytes']:,} bytes ({stats['total_mb']:.2f} MB)")
                report.append(f"     ‚Ä¢ S·ªë g√≥i tin: {stats['packets']:,}")
                report.append(f"     ‚Ä¢ Th·ªùi gian ho·∫°t ƒë·ªông: {stats['duration']:.1f} gi√¢y ({stats['start_time']:.1f}s ‚Üí {stats['end_time']:.1f}s)")
                
                # Calculate efficiency
                efficiency = (stats['avg_throughput'] / 5.0) * 100  # Assuming 5 Mbps WAN
                report.append(f"     ‚Ä¢ Hi·ªáu su·∫•t s·ª≠ d·ª•ng WAN: {efficiency:.1f}%")
                
            elif 'avg_cwnd' in stats:  # CWND data
                report.append(f"  üîß Congestion Window:")
                report.append(f"     ‚Ä¢ Trung b√¨nh: {stats['avg_cwnd']:.0f} bytes ({stats['avg_cwnd_kb']:.1f} KB)")
                report.append(f"     ‚Ä¢ T·ªëi ƒëa: {stats['max_cwnd']:,} bytes ({stats['max_cwnd_kb']:.1f} KB)")
                report.append(f"     ‚Ä¢ T·ªëi thi·ªÉu: {stats['min_cwnd']:,} bytes ({stats['min_cwnd_kb']:.1f} KB)")
                report.append(f"     ‚Ä¢ ƒê·ªô l·ªách chu·∫©n: {stats['std_cwnd']:.0f} bytes")
                report.append(f"     ‚Ä¢ TƒÉng/Gi·∫£m: {stats['cwnd_increases']}/{stats['cwnd_decreases']} l·∫ßn")
                report.append(f"     ‚Ä¢ ƒê·ªô ·ªïn ƒë·ªãnh: {stats['cwnd_stability']:.3f} (0-1)")
        
        # Network Analysis
        report.append("\nüåê PH√ÇN T√çCH M·∫†NG T·ªîNG TH·ªÇ")
        report.append("-" * 40)
        
        # Calculate total network utilization
        total_throughput = sum(stats.get('avg_throughput', 0) for stats in self.stats.values() if 'avg_throughput' in stats)
        wan_utilization = (total_throughput / 5.0) * 100
        
        report.append(f"‚Ä¢ T·ªïng throughput m·∫°ng: {total_throughput:.2f} Mbps")
        report.append(f"‚Ä¢ S·ª≠ d·ª•ng bƒÉng th√¥ng WAN: {wan_utilization:.1f}% (5 Mbps)")
        report.append(f"‚Ä¢ Tr·∫°ng th√°i m·∫°ng: {'Qu√° t·∫£i' if wan_utilization > 100 else 'B√¨nh th∆∞·ªùng' if wan_utilization > 80 else 'T·ªëi ∆∞u'}")
        
        # Recommendations
        report.append("\nüí° KHUY·∫æN NGH·ªä")
        report.append("-" * 40)
        
        if 'newreno_rx' in self.stats and 'reno_rx' in self.stats:
            newreno_perf = self.stats['newreno_rx']['avg_throughput']
            reno_perf = self.stats['reno_rx']['avg_throughput']
            
            if newreno_perf > reno_perf * 1.1:
                report.append("‚úÖ TCP NewReno cho hi·ªáu su·∫•t v∆∞·ª£t tr·ªôi so v·ªõi TCP Reno")
                report.append("   ‚Üí Khuy·∫øn ngh·ªã s·ª≠ d·ª•ng TCP NewReno cho c√°c ·ª©ng d·ª•ng quan tr·ªçng")
            elif abs(newreno_perf - reno_perf) < 0.1:
                report.append("‚öñÔ∏è Hi·ªáu su·∫•t TCP NewReno v√† TCP Reno t∆∞∆°ng ƒë∆∞∆°ng")
                report.append("   ‚Üí L·ª±a ch·ªçn t√πy thu·ªôc v√†o y√™u c·∫ßu c·ª• th·ªÉ")
            
            if wan_utilization > 100:
                report.append("‚ö†Ô∏è M·∫°ng ƒëang qu√° t·∫£i")
                report.append("   ‚Üí C·∫ßn t·ªëi ∆∞u h√≥a traffic ho·∫∑c n√¢ng c·∫•p bƒÉng th√¥ng")
            
            if 'newreno_cwnd' in self.stats and 'reno_cwnd' in self.stats:
                if self.stats['newreno_cwnd']['cwnd_stability'] > self.stats['reno_cwnd']['cwnd_stability']:
                    report.append("üìà TCP NewReno c√≥ CWND ·ªïn ƒë·ªãnh h∆°n")
                    report.append("   ‚Üí Ph√π h·ª£p cho m√¥i tr∆∞·ªùng m·∫°ng c√≥ ƒë·ªô tr·ªÖ cao")
        
        report.append("\n" + "="*80)
        report.append("H·∫æT B√ÅO C√ÅO")
        report.append("="*80)
        
        # Save report
        with open('tcp_analysis_report.txt', 'w', encoding='utf-8') as f:
            f.write('\n'.join(report))
        
        print("‚úÖ ƒê√£ l∆∞u b√°o c√°o: tcp_analysis_report.txt")
        
        # Print summary to console
        print("\n" + "="*60)
        print("üìã T√ìM T·∫ÆT K·∫æT QU·∫¢ PH√ÇN T√çCH")
        print("="*60)
        for line in report[6:20]:  # Print summary section
            print(line)
        print("="*60)
    
    def run_full_analysis(self):
        """Ch·∫°y ph√¢n t√≠ch ƒë·∫ßy ƒë·ªß"""
        print("üöÄ B·∫Øt ƒë·∫ßu ph√¢n t√≠ch ƒë·∫ßy ƒë·ªß TCP NewReno vs TCP Reno")
        print("="*60)
        
        self.load_all_data()
        self.calculate_statistics()
        self.create_comprehensive_plots()
        self.generate_detailed_report()
        
        print("\nüéâ HO√ÄN TH√ÄNH PH√ÇN T√çCH ƒê·∫¶Y ƒê·ª¶!")
        print("üìÅ C√°c file ƒë∆∞·ª£c t·∫°o:")
        print("   ‚Ä¢ tcp_throughput_analysis.png - Ph√¢n t√≠ch throughput")
        print("   ‚Ä¢ tcp_cwnd_analysis.png - Ph√¢n t√≠ch congestion window")
        print("   ‚Ä¢ tcp_network_analysis.png - Ph√¢n t√≠ch m·∫°ng t·ªïng th·ªÉ")
        print("   ‚Ä¢ tcp_analysis_report.txt - B√°o c√°o chi ti·∫øt")
        print("="*60)

if __name__ == "__main__":
    analyzer = TCPAnalyzer()
    analyzer.run_full_analysis() 